---
date: 2020-06-24 10:00:00 +09:00
title: mroongaで考えた
description: 実測を元にしただけで未検証のただのメモ
tags:
  - mroonga
# prev:
# next:
---

## １つめ

1つのテーブルにmroongaのfulltextカラムが2つあり、同じ文字列を検索したいとする。
次の様に、OR条件にするとインデックスが使用されなかった。
```
fulltext1=? OR fulltext2=?
```
原因はおそらくmysqlのインデックス制限だけど、mroongaの仕様かもしれない環境依存かもしれないし未調査。

回避する方法としては、
1. fulltextカラム毎にselectしてunionする（それぞれのインデックスを使用する目的）
1. fulltextのマルチインデックスを別に作成してMATCH句で指定する
があった。

前者は、ほぼ同じクエリの連結になるので冗長的。
取得するカラムや別のテーブルと結合している場合等、unionして問題ないかの確認は必要になる。

後者は、union allと同等でどちらかにあればヒットする。
ただし、fulltextカラムの組み合わせの数だけインデックスが必要になるので上限がある。

## ２つめ

mroongaのfulltextカラムがある2つのテーブル(A,B)とそれぞれのidを外部参照しているテーブル(C)の3つを結合してselectしたいとする。
それぞれ数百万レコード入っている。
AとBのfulltextカラムから検索する文字列は異なる。

まず、普通に結合してみた。[SELECT1]
```
from C join A on C.a_id=B.id join B on C.b_id=B.id
```
AとBはfulltextインデックスを使わなければならず、
AとBは関係性は希薄でレコード数もまるで異なるため、
Cには共通して使えるインデックスは作れない。
この時点で詰んでたけど、LEFT JOINにすると実行計画が変わり、
期待するインデックスを使ってくれるようになったりしたので、
最悪アプリ側でごにょればいいやといろいろ試してみたが、
force indexしても無駄だったり、オプティマイザ調査まで時間かけてられないので無理でした。

次に、サブクエリにしてみた。[SELECT2]
```
from (C join A on C.a_id=B.id) AS CA join (C join B on C.b_id=B.id) AS CB on CA.id=CB.id
```
サブクエリで期待するインデックスを使ってくれるが、件数の違いがボトルネックになっていた。
考えたら等価結合なのでDISTINCTしたら改善できた。
ただ、このやり方でもサブクエリで取得したレコードが多いと遅い。

とりあえず今回は、
- AまたはBどちらかのfulltextカラムを検索するか、またはfulltextカラムを検索しない場合、[SELECT1]で実行
- AとBどちらのfulltextも検索する場合、[SELECT2]で実行（ただし範囲が広いと遅い）
という場合分けの実装で終わらせた。

完全に解消するには、3テーブルを1つにすればよさそう。
インデックスの組み合わせが上限に到達しなければだけど。

